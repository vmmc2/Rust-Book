# Chapter 006 - Enums and Pattern Matching

## Intro
* __In this chapter, we’ll look at enumerations, also referred to as enums.__
* __Enums allow you to define a type by enumerating its possible variants.__
* __Pay attention to the fact that enums, as structs, allow the user to define new types. However, its approach to do such a thing is completely different.__
* __In this chapter we’ll explore a particularly useful enum, called ```Option```, which expresses that a value can be either something or nothing.__

## Defining Enums
* Comparing Enums and Structs:
  * Structs: Give you a way of grouping together related fields and data, like a ```Rectangle``` with its field (```width``` and ```height```).
  * Enums: Give you a way of saying a value is one of a possible set of values.
* Enums Use Case #1:
  * For example, we may want to say that ```Rectangle``` is one of a set of possible shapes that also includes ```Circle``` and ```Triangle```.
  * To do this, Rust allows us to encode these possibilities as an enum.
* Enums Use Case #2:
  * Say we need to work with IP addresses.
  * Currently, two major standards are used for IP addresses: version four (v4) and version six (v6).
  * Because these are the only possibilities for an IP address that our program will come across, we can enumerate all possible variants.
  * Any IP address can be either a version four or a version six address, but not both at the same time.
  * That property of IP addresses makes the enum data structure appropriate because an enum value can only be one of its variants.
  * Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.
  * We can express this concept in code by defining an ```IpAddrKind``` enumeration and listing the possible kinds of an IP address:
  ```rust
  enum IpAddrKind {
    V4,
    V6,
  }
  ```

## Enum Values
* We can create instances of each of the two variants of ```IpAddrKind``` like this:
```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```
* Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two.
* This is useful because now both values ```IpAddrKind::V4``` and ```IpAddrKind::V6``` are of the same type: ```IpAddrKind```.
* Once we have defined a new type using the ```enum``` keyword, we can start using such new type inside our codebase without problems:
  * We can define functions that receive a value of such type as a parameter:
  ```rust
  fn route(ip_kind: IpAddrKind) {
    // Do soemthing here...
  }
  ```
  * Once we've defined such function, we can call it passing one of the variants defined inside the enum as an argument:
  ```rust
  route(IpAddrKind::V4);
  route(IpAddrKind::V6);
  ```
* __Thinking more about our IP address type, at the moment we don’t have a way to store the actual IP address data. We only know what kind it is.__
  * This raises the question: What if we want to store IP address data inside (related to) our IP address type?
  * Here, we'll see two approaches to solve this problem:
  1. Approach #1 (Combining structs and enums) - Not so good
    ```rust
    enum IpAddrKind {
      V4,
      V6,
    }

    struct IpAddr {
      kind: IpAddrKind,
      address: String,
    }

    let home = IpAddr {
      kind: IpAddrKind::V4,
      address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
      kind: IpAddrKind::V6,
      address: String::from("::1"),
    };
    ```
    * __We’ve used a ```struct``` to bundle the ```kind``` and ```address``` values together, so now the variant is associated with the value.__
  2. Approach #2 (Using only enums) - Better
    ```rust
    enum IpAddr {
      V4(String),
      V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
    ```
    * __However, representing the same concept using just an ```enum``` is way more concise: rather than an ```enum``` inside a ```struct```, we can put data directly into each ```enum``` variant.__
    * __We attach data to each variant of the ```enum``` directly, so there is no need for an extra struct.__
    * __Here, it’s also easier to see another detail of how ```enums``` work: the name of each ```enum``` variant that we define also becomes a function that constructs an instance of the ```enum```.__
    * That is, ```IpAddr::V4()``` is a function call that takes a ```String``` argument and returns an instance of the ```IpAddr``` type. We automatically get this constructor function defined as a result of defining the ```enum```.
    * __There’s another important advantage to using an ```enum``` rather than a ```struct```: each variant can have different types and amounts of associated data.__
      * IP addresses (V4) will always have four numeric components that will have values between 0 and 255.
      * IP addresses (V6) will always have an alphanumeric value.
    * __If we wanted to store V4 addresses as four ```u8``` values but still express V6 addresses as one ```String``` value, we wouldn’t be able to with a ```struct```, since it does not provide such flexibility.__
    * However, we can do this with ease by using enums:
    ```rust
    enum IpAddr {
      V4(u8, u8, u8, u8),
      V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
    ```
* __IMPORTANT: You can put any kind of data inside an ```enum``` variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.__

## Taking a deeper dive into the use of ```enum```
* Let’s look at another example of an ```enum```. This one has a wide variety of types embedded in its variants:
```rust
enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(i32, i32, i32),
}
```
* As you can see, this newly created ```enum``` has 4 possible variants. Namely:
  * ```Quit```: Which has no data associated with it at all.
  * ```Move```: Which has named fields, like a ```struct``` does.
  * ```Write```: Which includes a single ```String``` value.
  * ```ChangeColor```: Which includes 3 ```i32``` values.
* __Pay atention to the following: Defining an ```enum``` with variants such as the ones above is similar to defining different kinds of ```struct``` definitions, except the ```enum``` doesn’t use the ```struct``` keyword and all the variants are grouped together under the ```Message```. However, if we used the different structs, each of which has its own type, we couldn’t as easily define a function to take any of these kinds of messages as we could with the ```Message``` enum.__
* __There is one more similarity between enums and structs: just as we’re able to define methods on structs using ```impl```, we’re also able to define methods on enums, as the example of code snippet below shows:__
```rust
impl Message {
  fn call(&self) {
    // method body would be defined here
  }
}

let m = Message::Write(String::from("hello"));
m.call();
```
* The body of the method would use ```self``` to get the value that we called the method on. In this example, we’ve created a variable ```m``` that has the value ```Message::Write(String::from("hello"))```, and that is what ```self``` will be in the body of the ```call``` method when ```m.call()``` runs.

## The ```Option``` Enum and Its Advantages Over Null Values
