# Chapter 005 - Using Structs to Structure Related Data

## Intro
* A structure (or struct) is a custom data type available in Rust that lets you package and name multiple related values that make a meaningful group.
* The concept of a structure is very similar to the concept of an object's data attributes.
* As you've previously seen, a structure is not the only way to package multiple values. It's also possible to do such a thing by using tuples. However, there are scenarios where one is better than the other.
* It's also possible to define behavior associated to the created structure by defining associated functions. Such type of functions is called methods.

## Defining and Instantiating Structs
* Structs and Tuples are very similar in the way that both hold multiple related values.
* The pieces (values) of a struct can be different types, as it happens in a tuple. Unlike with tuples, in a struct you’ll name each piece of data so it’s clear what the values mean.
* Moreover, when dealing with structs, you don’t have to rely on the order of the data to specify or access the values of an instance.
* The code snippet below shows how a struct is defined in Rust:
```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```
  * We define such a thing using the keyword ```struct```.
  * Then, we define a name for the struct. Such a name should tell us an idea of what the package of value represents.
  * Then, inside curly braces, we have the definition of the names and types of the pieces of data that make the struct, which we call fields.
* __To use a struct in Rust after we've define it, we should follow the steps below:.__
  * __To use a struct after we’ve defined it, we create an instance of that struct by specifying concrete values for each of the fields.__
  * __We create an instance by stating the name of the struct and then add curly brackets containing ```key: value``` pairs, where the keys are the names of the fields and the values are the data we want to store in those fields.__
  * __We don’t have to specify the fields in the same order in which we declared them in the struct.__
  * Example of Rust code snippet that does this:
  ```rust
  fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
  }
  ```
* __To access a specific value from a struct, we must use dot notation. For example, if we want to access the email of the user defined in the code above, we need to write the following: ```user1.email```.__
* __IMPORTANT: If the instance of the struct is mutable, we can change a value by using the dot notation and assigning into a particular field. Otherwise, we can't do such a thing.__
  ```rust
  fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
  }
  ```
* __IMPORTANT: Note that the entire instance must be mutable; Rust doesn’t allow us to mark only certain fields as mutable.__
* Tackling another subject, as with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.
* Below, we have a code snippet that shows this functionality being used inside a function that builds and returns an instance of a struct:
```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```
