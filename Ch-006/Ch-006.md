# Chapter 006 - Enums and Pattern Matching

## Intro
* __In this chapter, we’ll look at enumerations, also referred to as enums.__
* __Enums allow you to define a type by enumerating its possible variants.__
* __Pay attention to the fact that enums, as structs, allow the user to define new types. However, its approach to do such a thing is completely different.__
* __In this chapter we’ll explore a particularly useful enum, called ```Option```, which expresses that a value can be either something or nothing.__

## Defining Enums
* Comparing Enums and Structs:
  * Structs: Give you a way of grouping together related fields and data, like a ```Rectangle``` with its field (```width``` and ```height```).
  * Enums: Give you a way of saying a value is one of a possible set of values.
* Enums Use Case #1:
  * For example, we may want to say that ```Rectangle``` is one of a set of possible shapes that also includes ```Circle``` and ```Triangle```.
  * To do this, Rust allows us to encode these possibilities as an enum.
* Enums Use Case #2:
  * Say we need to work with IP addresses.
  * Currently, two major standards are used for IP addresses: version four (v4) and version six (v6).
  * Because these are the only possibilities for an IP address that our program will come across, we can enumerate all possible variants.
  * Any IP address can be either a version four or a version six address, but not both at the same time.
  * That property of IP addresses makes the enum data structure appropriate because an enum value can only be one of its variants.
  * Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.
  * We can express this concept in code by defining an ```IpAddrKind``` enumeration and listing the possible kinds of an IP address:
  ```rust
  enum IpAddrKind {
    V4,
    V6,
  }
  ```

## Enum Values
* We can create instances of each of the two variants of ```IpAddrKind``` like this:
```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```
* Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two.
* This is useful because now both values ```IpAddrKind::V4``` and ```IpAddrKind::V6``` are of the same type: ```IpAddrKind```.
* Once we have defined a new type using the ```enum``` keyword, we can start using such new type inside our codebase without problems:
  * We can define functions that receive a value of such type as a parameter:
  ```rust
  fn route(ip_kind: IpAddrKind) {
    // Do soemthing here...
  }
  ```
  * Once we've defined such function, we can call it passing one of the variants defined inside the enum as an argument:
  ```rust
  route(IpAddrKind::V4);
  route(IpAddrKind::V6);
  ```
* __Thinking more about our IP address type, at the moment we don’t have a way to store the actual IP address data. We only know what kind it is.__
  * This raises the question: What if we want to store IP address data inside (related to) our IP address type?
  * Here, we'll see two approaches to solve this problem:
  1. Approach #1 (Combining structs and enums) - Not so good
    ```rust
    enum IpAddrKind {
      V4,
      V6,
    }

    struct IpAddr {
      kind: IpAddrKind,
      address: String,
    }

    let home = IpAddr {
      kind: IpAddrKind::V4,
      address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
      kind: IpAddrKind::V6,
      address: String::from("::1"),
    };
    ```
    * __We’ve used a ```struct``` to bundle the ```kind``` and ```address``` values together, so now the variant is associated with the value.__
  2. Approach #2 (Using only enums) - Better
    ```rust
    enum IpAddr {
      V4(String),
      V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
    ```
    * __However, representing the same concept using just an ```enum``` is way more concise: rather than an ```enum``` inside a ```struct```, we can put data directly into each ```enum``` variant.__
    * __We attach data to each variant of the ```enum``` directly, so there is no need for an extra struct.__
    * __Here, it’s also easier to see another detail of how ```enums``` work: the name of each ```enum``` variant that we define also becomes a function that constructs an instance of the ```enum```.__
    * That is, ```IpAddr::V4()``` is a function call that takes a ```String``` argument and returns an instance of the ```IpAddr``` type. We automatically get this constructor function defined as a result of defining the ```enum```.
    * __There’s another important advantage to using an ```enum``` rather than a ```struct```: each variant can have different types and amounts of associated data.__
      * IP addresses (V4) will always have four numeric components that will have values between 0 and 255.
      * IP addresses (V6) will always have an alphanumeric value.
    * __If we wanted to store V4 addresses as four ```u8``` values but still express V6 addresses as one ```String``` value, we wouldn’t be able to with a ```struct```, since it does not provide such flexibility.__
    * However, we can do this with ease by using enums:
    ```rust
    enum IpAddr {
      V4(u8, u8, u8, u8),
      V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
    ```
* __IMPORTANT: You can put any kind of data inside an ```enum``` variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.__

## Taking a deeper dive into the use of ```enum```
* Let’s look at another example of an ```enum```. This one has a wide variety of types embedded in its variants:
```rust
enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(i32, i32, i32),
}
```
* As you can see, this newly created ```enum``` has 4 possible variants. Namely:
  * ```Quit```: Which has no data associated with it at all.
  * ```Move```: Which has named fields, like a ```struct``` does.
  * ```Write```: Which includes a single ```String``` value.
  * ```ChangeColor```: Which includes 3 ```i32``` values.
* __Pay atention to the following: Defining an ```enum``` with variants such as the ones above is similar to defining different kinds of ```struct``` definitions, except the ```enum``` doesn’t use the ```struct``` keyword and all the variants are grouped together under the ```Message```. However, if we used the different structs, each of which has its own type, we couldn’t as easily define a function to take any of these kinds of messages as we could with the ```Message``` enum.__
* __There is one more similarity between enums and structs: just as we’re able to define methods on structs using ```impl```, we’re also able to define methods on enums, as the example of code snippet below shows:__
```rust
impl Message {
  fn call(&self) {
    // method body would be defined here
  }
}

let m = Message::Write(String::from("hello"));
m.call();
```
* The body of the method would use ```self``` to get the value that we called the method on. In this example, we’ve created a variable ```m``` that has the value ```Message::Write(String::from("hello"))```, and that is what ```self``` will be in the body of the ```call``` method when ```m.call()``` runs.

## The ```Option``` Enum and Its Advantages Over Null Values
* This section explores a case study of ```Option```, which is another enum defined by the standard library.
* __The ```Option``` type encodes the very common scenario in which a value could be something or it could be nothing.__
* For example, if you request the first item in a non-empty list, you would get a value. If you request the first item in an empty list, you would get nothing.
* __Expressing this concept in terms of the type system means the compiler can check whether you’ve handled all the cases you should be handling. This functionality can prevent bugs that are extremely common in other programming languages.__
* __IMPORTANT: Rust doesn’t have the null feature that many other languages have. Null is a value that means there is no value there. In languages with null, variables can always be in one of two states: null or not-null.__
* __Quote from Tony Hoare, the invetor of ```Null```: "At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.".__
* The problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.
* __However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.__
* __IMPORTANT: The problem isn’t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent.__
* Such enum is called ```Option<T>```.
```rust
enum Option<T> {
  None,
  Some(T),
}
```
* The ```Option<T>``` enum is so useful that it’s even included in the prelude. This means that you don’t need to bring it into scope explicitly.
* The variants (possible values) of the ```Option<T>``` enum are also included in the prelude. Thus, you can use ```Some``` and ```None``` directly without the ```Option::``` prefix.
* __The ```<T>``` syntax is a feature of Rust we haven’t talked about yet. It’s a generic type parameter. For now, all you need to know is that ```<T>``` means that the ```Some``` variant of the ```Option``` enum can hold one piece of data of any type, and that each concrete type that gets used in place of ```T``` makes the overall ```Option<T>``` type a different type (which means that ```Option<i32>``` and ```Option<u32>``` are different types, for example).__
* Example of Rust code snippet that show this idea:
```rust
let some_number = Some(5); // Is of type Option<i32>.
let some_char = Some('e'); // Is of type Option<char>. 

let absent_number: Option<i32> = None; // Is of type Option<i32>.
```
* __For the first two variables (```some_number``` and ```some_char```) Rust can infer these types (we don't need to write type annotations) because we’ve specified a value inside the ```Some``` variant.__
* __For the last variable (```absent_number```) we need to annotate the overall ```Option``` type: the compiler can’t infer the type that the corresponding ```Some``` variant will hold by looking only at a ```None``` value. Here, we tell Rust that we mean for ```absent_number``` to be of type ```Option<i32>```.__
* Therefore, we have the following:
  * When we have a ```Some``` value, we know that a value is present and the value is held within the ```Some```. 
  * When we have a ```None``` value, in some sense it means the same thing as null. In other words, we don’t have a valid value.
* __IMPORTANT: So why is having ```Option<T>``` any better than having null?__
  * __In short, because ```Option<T>``` and ```T``` (where ```T``` can be any type) are different types, the compiler won’t let us use an ```Option<T>``` value as if it were definitely a valid value.__
  * __We can see this in the following code snippet that the Rust compiler won't compile:__
  ```rust
  let x: i8 = 5;
  let y: Option<i8> = Some(5);

  let sum = x + y; // This line will throw a compiler error.
  ```
  * __In effect, the error message means that Rust doesn’t understand how to add an ```i8``` and an ```Option<i8>```, because they’re different types:__
    * __When we have a value of a type like ```i8``` in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value.__
    * __However, when we have an ```Option<i8>``` (or whatever type of value we’re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.__
    * __In other words, you have to convert an ```Option<T>``` to a ```T``` before you can perform ```T``` operations with it.__
    * __Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.__

## Dealing with ```Option<T>```
* In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value ```Option<T>```.
* Then, when you use that value, you are required to explicitly handle the case when the value is null.
* Everywhere that a value has a type that isn’t an ```Option<T>```, you can safely assume that the value isn’t null (this was a deliberate design decision for Rust to limit null’s pervasiveness and increase the safety of Rust code).
* So how do you get the ```T``` value out of a ```Some``` variant when you have a value of type ```Option<T>``` so that you can use that value? The ```Option<T>``` enum has a large number of methods that are useful in a variety of situations. Check the official docs to know what methods are available and how you can use them.
* __In general, in order to use an ```Option<T>``` value, you want to have code that will handle each variant:__ 
  * You want some code that will run only when you have a ```Some(T)``` value, and this code is allowed to use the inner ```T``` value.
  * You want some other code to run only if you have a ```None``` value, and that code doesn’t have a ```T``` value available.
  * The ```match``` expression is a control flow construct that does just this when used with enums. It will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.

## The ```match``` Control Flow Construct
* It's an extremely powerful control flow construct that allows you to compare a value against a series of patterns and then execute code based on which pattern matches.
* You can think of it as a ```switch``` statement on steroids.
* __Patterns can be made up of literal values, variable names, wildcards, and many other things.__
* __What makes the ```match``` expression different (and more powerful) than the ```switch``` statement?__
  * __Expressiveness of the patterns.__
  * __The compiler confirms that all possible cases are handled.__
* How does the ```match``` expression really works?
  * A value go through each pattern in a match, and at the first pattern the value “fits” the value falls into the associated code block to be used during execution.
* Example of code snippet that uses the ```match``` expression:
  * 
  ```rust
  enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
  }

  fn value_in_cents(coin: Coin) -> u8 {
    match coin {
      Coin::Penny => 1,
      Coin::Nickel => 5,
      Coin::Dime => 10,
      Coin::Quarter => 25,
    }
  }
  ```
  * This seems very similar to a conditional expression used with ```if```.
  * However, there’s a big difference: with ```if```, the condition needs to evaluate to a ```Boolean``` value, but here it can be any type.
  * The type of ```coin``` in this example is the ```Coin``` enum that we defined on the first line.
  * Next are the arms of the ```match``` expression. An arm has two parts: a pattern and some code.
* __IMPORTANT: When the ```match``` expression executes, it compares the resultant value against the pattern of each arm, in order (from top to bottom). When the value fits with the first pattern it encounters, the code block associated to that arm/pattern will be executed and the last expression inside the code block will be returned for the entire ```match``` expression.__
* Pay attention to the fact that what separates one arm from another inside a ```match``` expression is a comma (```,```).
* __IMPORTANT: If you want to run multiple lines of code in a match arm, you must put your code inside curly brackets, and the comma following the arm is then optional.__

## Patterns That Bind to Values
* __Another useful feature of ```match``` expression arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of ```enum``` variants.__
* Example of code snippet that illustrates such behavior:
```rust
#[derive(Debug)] // So we can inspect the state in a minute
enum UsState {
  Alabama,
  Alaska,
  // --snip--
}

enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
  match coin {
    Coin::Penny => 1,
    Coin::Nickel => 5,
    Coin::Dime => 10,
    Coin::Quarter(state) => {
        println!("State quarter from {:?}!", state);
        25
    }
  }
}
```
* __If we were to call ```value_in_cents(Coin::Quarter(UsState::Alaska))```, ```coin``` would be ```Coin::Quarter(UsState::Alaska)```. When we compare that value with each of the match arms, none of them match until we reach ```Coin::Quarter(state)```. At that point, the binding for state will be the value ```UsState::Alaska```. We can then use that binding in the ```println!``` expression, thus getting the inner state value out of the ```Coin``` enum variant for ```Quarter```.__

## Matching with ```Option<T>```
* Previously, we wanted to get the inner ```T``` value out of the ```Some``` case when using ```Option<T>```. We can also handle ```Option<T>``` using ```match```, as we did with the ```Coin``` enum.
* The only difference is that instead of comparing coins, we’ll compare the variants of ```Option<T>```.
* __Example: A function that takes in a parameter of type ```Option<i32>``` and, if there’s a value inside, adds 1 to that value. On the other hand, if there isn’t a value inside, the function should return the ```None``` value and not attempt to perform any operations:__
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
  match x {
    None => None,
    Some(i) => Some(i + 1),
  }
}

let five = Some(5); // Option<i32>::Some(5)
let six = plus_one(five); // Option<i32>::Some(6)
let none = plus_one(None); // Option<i32>::None
```
* __Combining ```match``` and enums is useful in many situations. You’ll see this pattern a lot in Rust code: ```match``` against an enum, bind a variable to the data inside, and then execute code based on it. It’s a bit tricky at first, but once you get used to it, you’ll wish you had it in all languages.__

## Matches Are Exhaustive
* __IMPORTANT: There’s one other aspect of ```match``` we need to discuss: the arms’ patterns must cover all possibilities.__
* Take a look at the code snippet below, which has a bug (it does not cover all possibilities) and, thus, won't compile:
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
  match x {
    Some(i) => Some(i + 1),
  }
}
```
* The bug is that we didn’t handle the ```None``` case.
* Rust knows that we didn’t cover every possible case, and even knows which pattern we forgot! Matches in Rust are exhaustive: we must exhaust every last possibility in order for the code to be valid.

## Catch-all Patterns and the ```_``` Placeholder
* __Using enums, we can also take special actions for a few particular values, but for all other values take one default action:__
  * Imagine we’re implementing a game where:
    * If you roll a 3 on a dice roll, your player doesn’t move, but instead gets a new fancy hat.
    * If you roll a 7, your player loses a fancy hat.
    * For all other values, your player moves that number of spaces on the game board.
  * The code snippet below shows how one can implement such logic:
  ```rust
  let dice_roll = 9;

  match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    other => move_player(other),
  }

  fn add_fancy_hat() {}
  fn remove_fancy_hat() {}
  fn move_player(num_spaces: u8) {}
  ```
  * __IMPORTANT: This code compiles, even though we haven’t listed all the possible values a ```u8``` can have, because the last pattern will match all values not specifically listed. This catch-all pattern meets the requirement that match must be exhaustive.__
  * __IMPORTANT: Note that we have to put the catch-all arm last because the patterns are evaluated in order. If we put the catch-all arm earlier, the other arms would never run, so Rust will warn us if we add arms after a catch-all!__
  * __IMPORTANT: Rust also has a pattern we can use when we want a catch-all but don’t want to use the value in the catch-all pattern: ```_``` is a special pattern that matches any value and does not bind to that value. This tells Rust we aren’t going to use the value, so Rust won’t warn us about an unused variable.__

## Concise Control Flow with ```if let```
* 