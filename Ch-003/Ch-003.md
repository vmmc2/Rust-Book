# Chapter 003 - Common Programming Concepts

## Variables and Mutability
* __By default, in Rust, variables are immutable. This is a good design decision because it favors safety and concurrency.__
* However, nothing stops you from making your variables mutable.
* You can make a variable mutable by adding the ```mut``` keyword in front of the variable name. Adding such keyword also conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable's value.
* Example of Rust code snippet:
```rs
fn main(){
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 13;
    println!("The new value of x is: {x}");
}
```
* __Ultimately, deciding whether to use mutability or not is up to you and depends on what you think is clearest in that particular situation.__


### Constants
* Constants are basically values that bounded to a name and cannot change later in time.
* However, there are a few differences between constants and variables:
    * First, constants aren't immutable by default. They are ALWAYS immutable. This means that you cannot use the ```mut``` keyword in a constant declaration.
    * Second, to declare a constant, you must use the ```const``` keyword.
    * Third, when you declare a constant, you must put a type annotation. Otherwise, you'll receive an error.
    * Fourth, constants may be set only to a constant expression, not the result of a value that could only be computed at runtime. __It's a good idea to take a look at the Rust reference to see what's considered a constant expression and what is not. The compiler is able to evaluate a limited set of operations at compile time.__
* Rust’s naming convention for constants is to use all uppercase with underscores between words.


### Shadowing
* In Rust, you can declare a new variable with the same name as a previous variable. __This means that you can re-declare a variable in this language without receiving any errors.__
* __Rustaceans say that the first variable is shadowed by the second, which means that the second variable is what the compiler will see when you use the name of the variable.__
* In effect, the second variable overshadows the first, taking any uses of the variable name to itself until either it itself is shadowed or the scope ends. We can shadow a variable by using the same variable’s name and repeating the use of the let keyword as follows:
```rust
fn main() {
    let x = 5; // 5;

    let x = x + 1; // 6

    {
        let x = 2 * x; // 12
        println!("The value of x in the inner scope is: {x}"); //12

    }

    println!("The value of x is: {x}"); // 6
}
```
* __Shadowing is different from marking a variable as ```mut``` because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the ```let``` keyword. By using ```let```, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.__
* __The other difference between mut and shadowing is that because we’re effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, and then we want to store that input as a number:__
```rust
let spaces = "      ";
let spaces = spaces.len();
```
* By using the ```let``` keyword, we are basically creating a new variable, which allows us to do some "tricks". If we don't use such keyword, we cannot perform such "tricks".


## Data Types
* In Rust, every value has a certain data type associated to it.
