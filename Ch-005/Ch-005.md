# Chapter 005 - Using Structs to Structure Related Data

## Intro
* A structure (or struct) is a custom data type available in Rust that lets you package and name multiple related values that make a meaningful group.
* The concept of a structure is very similar to the concept of an object's data attributes.
* As you've previously seen, a structure is not the only way to package multiple values. It's also possible to do such a thing by using tuples. However, there are scenarios where one is better than the other.
* It's also possible to define behavior associated to the created structure by defining associated functions. Such type of functions is called methods.

## Defining and Instantiating Structs
* Structs and Tuples are very similar in the way that both hold multiple related values.
* The pieces (values) of a struct can be different types, as it happens in a tuple. Unlike with tuples, in a struct you’ll name each piece of data so it’s clear what the values mean.
* Moreover, when dealing with structs, you don’t have to rely on the order of the data to specify or access the values of an instance.
* The code snippet below shows how a struct is defined in Rust:
```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```
  * We define such a thing using the keyword ```struct```.
  * Then, we define a name for the struct. Such a name should tell us an idea of what the package of value represents.
  * Then, inside curly braces, we have the definition of the names and types of the pieces of data that make the struct, which we call fields.
* __To use a struct in Rust after we've define it, we should follow the steps below:.__
  * __To use a struct after we’ve defined it, we create an instance of that struct by specifying concrete values for each of the fields.__
  * __We create an instance by stating the name of the struct and then add curly brackets containing ```key: value``` pairs, where the keys are the names of the fields and the values are the data we want to store in those fields.__
  * __We don’t have to specify the fields in the same order in which we declared them in the struct.__
  * Example of Rust code snippet that does this:
  ```rust
  fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
  }
  ```
* __To access a specific value from a struct, we must use dot notation. For example, if we want to access the email of the user defined in the code above, we need to write the following: ```user1.email```.__
* __IMPORTANT: If the instance of the struct is mutable, we can change a value by using the dot notation and assigning into a particular field. Otherwise, we can't do such a thing.__
  ```rust
  fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
  }
  ```
* __IMPORTANT: Note that the entire instance must be mutable; Rust doesn’t allow us to mark only certain fields as mutable.__
* Tackling another subject, as with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.
* Below, we have a code snippet that shows this functionality being used inside a function that builds and returns an instance of a struct:
```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```

## Using the Field Init Shorthand
* This shorthand allows us to initialize an instance of a structure (struct) in a less verbose way.
* Take a look at the code snippet below that shows how this can be done:
```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username, // username: username,
        email, // email: email,
        sign_in_count: 1,
    }
}
```

## Creating Instances from Other Instances with Struct Update Syntax
* It’s often useful to create a new instance of a struct that includes most of the values from another instance, but changes some.
* Such a thing can be done by using the struct update syntax.
* Without the Struct Update Syntax, here's how one could create a new User instance whose value for the ```email``` field is different but all other values are equal to the values of another User instance previously declared:
```rust
fn main() {
  // --snip--  Here is the assignment of the first User instance to a variable called "user1".

  let user2 = User {
    active: user1.active,
    username: user1.username,
    email: String::from("another@example.com"),
    sign_in_count: user1.sign_in_count,
  };
}
```
* __Using the struct update syntax, we can achieve the same effect with less code. The syntax ```..``` specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.__
```rust
fn main() {
  // --snip-- Here is the assignment of the first User instance to a variable called "user1".

  let user2 = User {
    email: String::from("another@example.com"),
    ..user1
  };
}
```
* __VERY IMPORTANT NOTES:__
  * __Note that the struct update syntax uses ```=``` like an assignment. This is because it moves the data, just as we saw in the “Variables and Data Interacting with Move” section.__
  * __In the example presented above, we can no longer use ```user1``` as a whole after creating ```user2``` because the ```String``` value in the ```username``` field of ```user1``` was moved into ```user2```.__
  * __If we had given ```user2``` new ```String``` values for both ```email``` and ```username```, and thus only used the ```active``` and ```sign_in_count``` values from ```user1```, then ```user1``` would still be valid after creating ```user2```.__
  * __Both ```active``` and ```sign_in_count``` are types that implement the ```Copy``` trait, so the behavior we discussed in the “Stack-Only Data: Copy” section would apply.__

## Using Tuple Structs Without Named Fields to Create Different Types
* Rust also supports structs that look similar to tuples, called tuple structs.
* Tuple structs have the added meaning the struct name provides but don’t have names associated with their fields; rather, they just have the types of the fields.
* Tuple structs are useful when you want to give the whole tuple a name and make the tuple a different type from other tuples, and when naming each field as in a regular struct would be verbose or redundant (for example: when we want the new type to represent a point inside the 2D or 3D space or when we want the new type to represent a RGB pixel).
* To define a tuple struct, start with the ```struct``` keyword and the struct name followed by the types in the tuple.
* Example code snippet:
```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```
* __IMPORTANT: Note that the ```black``` and ```origin``` values are different types because they’re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct might have the same types.__
* Moreover, tuple struct instances are similar to tuples in that you can destructure them into their individual pieces, and you can use a ```.``` followed by the index to access an individual value.

## Unit-Like Structs Without Any Fields
* You can also define structs that don’t have any fields!
* These are called unit-like structs.
* They behave in a similar way to ```()```.
* __Unit-like structs can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself.__
* Code snippet that declares and uses an Unit-Like Struct:
```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

## Ownership of Struct Data
* __In the ```User``` struct defined in the first example of this chapter, we used the owned ```String``` type rather than the ```&str``` string slice type.__
* __This is a deliberate choice because we want each instance of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.__
* __It’s also possible for structs to store references to data owned by something else, but to do so requires the use of lifetimes, a Rust feature that we’ll discuss later.__
* __Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is.__
* __If you try to store a reference in a struct without specifying lifetimes the compiler will throw an error.__

## Coding Program with Structs: Adding More Meaning
* __We use structs to add meaning by labeling the data.__
* __We can transform the tuple we’re using into a struct with a name for the whole as well as names for the parts (the fields inside the struct).__
```rust
struct Rectangle {
  width: u32,
  height: u32,
}

fn main() {
  let rect1 = Rectangle {
    width: 30,
    height: 50,
  };

  println!(
    "The area of the rectangle is {} square pixels.",
    area(&rect1)
  );
}

fn area(rectangle: &Rectangle) -> u32 {
  rectangle.width * rectangle.height
}
```
* __Our ```area``` function is now defined with one parameter, which we’ve named ```rectangle```, whose type is an immutable borrow of a struct ```Rectangle``` instance.__
* __As mentioned in Chapter 4, we want to borrow the struct rather than take ownership of it.__
* __This way, ```main``` retains its ownership and can continue using ```rect1```, which is the reason we use the ```&``` in the function signature and where we call the function.__
* __Remember that accessing fields of a borrowed struct instance does not move the field values, which is why you often see borrows of structs.__
* __Our function signature for ```area``` now says exactly what we mean: calculate the area of ```Rectangle```, using its ```width``` and ```height``` fields.__

## Adding Useful Functionality with Derived Traits
* __It’d be useful to be able to print an instance of ```Rectangle``` while we’re debugging our program and see the values for all its fields.__
* __The ```println!``` macro can do many kinds of formatting, and by default, the curly brackets tell ```println!``` to use formatting known as ```Display```: output intended for direct end user consumption.__
* __The primitive types we’ve seen so far implement ```Display``` by default because there’s only one way you’d want to show a ```1``` or any other primitive type to a user.__
* __But with structs, the way ```println!``` should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown?__
* __Due to this ambiguity, Rust doesn’t try to guess what we want, and structs don’t have a provided implementation of ```Display``` to use with ```println!``` and the ```{}``` placeholder.__
* __We can try to display an instance of a struct by using the specifier ```:?```. The ```println!``` macro call will now look like ```println!("rect1 is {:?}", rect1);```. Putting the specifier ```:?``` inside the curly brackets tells ```println!``` we want to use an output format called ```Debug```.__
* __The ```Debug``` trait enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.__
* __However, to make this work, we have to explicitly opt in to make that functionality available for our struct. We can do this by following the code snippet below:__
```rust
#[derive(Debug)] // Adding the outer attribute just before the struct definition.
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```
* Now, this code will compile and also work as we want. It will show all the values for this instance of struct.
* If we want to print the values of the fields of an instance of a struct we can use another specifier instead. Such specifier is: ```{:#?}```.
* __IMPORTANT: Another way to print out a value using the ```Debug``` format is to use the ```dbg!``` macro, which takes ownership of an expression (as opposed to ```println!```, which takes a reference), prints the file and line number of where that ```dbg!``` macro call occurs in your code along with the resultant value of that expression, and returns ownership of the value.__
* Important thing to keep in mind while dealing with the ```dbg!``` and the ```println!``` macros:
  * ```dbg!```: Prints to the standard error console stream (```stderr```).
  * ```println!```: Prints to the standard output console stream (```stdout```).
* Example of code snippet that uses the ```dbg!``` macro:
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // Prints the value to stderr.
        height: 50,
    };

    dbg!(&rect1); // Prints the value to stderr.
}
```
* The ```dbg!``` macro can be really helpful when you’re trying to figure out what your code is doing!
* In addition to the ```Debug``` trait, Rust has provided a number of traits for us to use with the ```derive``` attribute that can add useful behavior to our custom types.

## Methods
* __Methods are similar to functions: we declare them with the ```fn``` keyword and a name, they can have parameters and a return value, and they contain some code that’s run when the method is called from somewhere else.__
* __Unlike functions, methods are defined within the context of a struct (or an enum or a trait object), and their first parameter is always ```self```, which represents the instance of the struct the method is being called on.__
* Changing the ```area``` function to an ```area``` method will give us the following:
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```
* To define the function within the context of ```Rectangle```, we start an ```impl``` (implementation) block for ```Rectangle```. __Everything within this ```impl``` block will be associated with the ```Rectangle``` type.__ Then we move the ```area``` function within the ```impl``` curly brackets and change the first (and in this case, only) parameter to be ```self``` in the signature and everywhere within the body.
* __Remember that the method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.__
* __IMPORTANT!__
  * __In the signature for area, we use ```&self``` instead of ```rectangle: &Rectangle```.__
  * __The ```&self``` is actually short for ```self: &Self```. Within an ```impl``` block, the type ```Self``` is an alias for the type that the ```impl``` block is for.__
  * __Methods must have a parameter named ```self``` of type ```Self``` for their first parameter, so Rust lets you abbreviate this with only the name ```self``` in the first parameter spot.__
  * __Note that we still need to use the ```&``` in front of the ```self``` shorthand to indicate that this method borrows the ```Self``` instance, just as we did in ```rectangle: &Rectangle```. Methods can take ownership of ```self```, borrow ```self``` immutably, as we’ve done here, or borrow ```self``` mutably, just as they can any other parameter.__
  * __We chose ```&self``` here for the same reason we used ```&Rectangle``` in the function version: we don’t want to take ownership, and we just want to read the data in the struct, not write to it.__
  * __If we wanted to change the instance that we’ve called the method on as part of what the method does, we’d use ```&mut self``` as the first parameter.__
  * Having a method that takes ownership of the instance by using just ```self``` as the first parameter is rare. This technique is usually used when the method transforms ```self``` into something else and you want to prevent the caller from using the original instance after the transformation.
* The main reason for using methods instead of functions is for organization.
* Note that we can choose to give a method the same name as one of the struct’s fields.
* __Often, but not always, when we give a method the same name as a field we want it to only return the value in the field and do nothing else. Methods like this are called getters, and Rust does not implement them automatically for struct fields as some other languages do. Getters are useful because you can make the field private but the method public, and thus enable read-only access to that field as part of the type’s public API. We will discuss what public and private are and how to designate a field or method as public or private in Chapter 7.__

## Methods with More Parameters
* Suppose that we want to implement a second method on the ```Rectangle``` struct. This time we want an instance of ```Rectangle``` to take another instance of ```Rectangle``` and return ```true``` if the second ```Rectangle``` can fit completely within ```self``` (the first ```Rectangle```); otherwise, it should return ```false```.
* Such method will be called ```can_hold```.
* We know we want to define a method, so it will be within the ```impl Rectangle``` block. The method name will be ```can_hold```, and it will take an immutable borrow of another ```Rectangle``` as a parameter. 
* Example of code snippet that implements the ```can_hold``` method described above:
```rust
impl Rectangle {
  fn area(&self) -> u32 {
    self.width * self.height
  }

  fn can_hold(&self, other: &Rectangle) -> bool {
    self.width > other.width && self.height > other.height
  }
}
```
* __You probably already know this, but methods can take multiple parameters that we add to the signature after the ```self``` parameter, and those parameters work just like parameters in functions.__

## Associated Functions
* __All functions defined within an ```impl``` block are called associated functions because they’re associated with the type named after the ```impl```.__
* __We can define associated functions that don’t have ```self``` as their first parameter (and thus are not methods) because they don’t need an instance of the type to work with.__
* We’ve already used one function like this: the ```String::from function``` that’s defined on the ```String``` type.
* __IMPORTANT: Associated functions that aren’t methods are often used for constructors that will return a new instance of the struct.__
* Example of code snippet: We could choose to provide an associated function named ```square``` that would have one dimension parameter and use that as both ```width``` and ```height```, thus making it easier to create a square ```Rectangle``` rather than having to specify the same value twice.
```rust
impl Rectangle {
  fn square(size: u32) -> Self {
    Self {
        width: size,
        height: size,
    }
  }
}
```
* The ```Self``` keywords in the return type and in the body of the function are aliases for the type that appears after the ```impl``` keyword, which, in this case, is ```Rectangle```.
* __To call this associated function, we use the ```::``` syntax with the struct name:__
```rust
let sq = Rectangle::square(3);
```
* __This function is namespaced by the struct. The ```::``` syntax is used for both associated functions and namespaces created by modules.__

## Multiple ```impl``` Blocks
* Each struct is allowed to have multiple ```impl``` blocks.
* There’s no reason to separate methods of a struct into multiple ```impl``` blocks, but this is valid syntax. 
* __When we discuss generic types and traits, we'll see scenarios where multiple ```impl``` blocks are useful.__