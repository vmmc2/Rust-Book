# Chapter 006 - Enums and Pattern Matching

## Intro
* __In this chapter, we’ll look at enumerations, also referred to as enums.__
* __Enums allow you to define a type by enumerating its possible variants.__
* __Pay attention to the fact that enums, as structs, allow the user to define new types. However, its approach to do such a thing is completely different.__
* __In this chapter we’ll explore a particularly useful enum, called ```Option```, which expresses that a value can be either something or nothing.__

## Defining Enums
* Comparing Enums and Structs:
  * Structs: Give you a way of grouping together related fields and data, like a ```Rectangle``` with its field (```width``` and ```height```).
  * Enums: Give you a way of saying a value is one of a possible set of values.
* Enums Use Case #1:
  * For example, we may want to say that ```Rectangle``` is one of a set of possible shapes that also includes ```Circle``` and ```Triangle```.
  * To do this, Rust allows us to encode these possibilities as an enum.
* Enums Use Case #2:
  * Say we need to work with IP addresses.
  * Currently, two major standards are used for IP addresses: version four (v4) and version six (v6).
  * Because these are the only possibilities for an IP address that our program will come across, we can enumerate all possible variants.
  * Any IP address can be either a version four or a version six address, but not both at the same time.
  * That property of IP addresses makes the enum data structure appropriate because an enum value can only be one of its variants.
  * Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.
  * We can express this concept in code by defining an ```IpAddrKind``` enumeration and listing the possible kinds of an IP address:
  ```rust
  enum IpAddrKind {
    V4,
    V6,
  }
  ```

## Enum Values
* We can create instances of each of the two variants of ```IpAddrKind``` like this:
```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```
* Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two.
* This is useful because now both values ```IpAddrKind::V4``` and ```IpAddrKind::V6``` are of the same type: ```IpAddrKind```.
* Once we have defined a new type using the ```enum``` keyword, we can start using such new type inside our codebase without problems:
  * We can define functions that receive a value of such type as a parameter:
  ```rust
  fn route(ip_kind: IpAddrKind) {
    // Do soemthing here...
  }
  ```
  * Once we've defined such function, we can call it passing one of the variants defined inside the enum as an argument:
  ```rust
  route(IpAddrKind::V4);
  route(IpAddrKind::V6);
  ```
* __Thinking more about our IP address type, at the moment we don’t have a way to store the actual IP address data. We only know what kind it is.__
  * This raises the question: What if we want to store IP address data inside (related to) our IP address type?
  * Here, we'll see two approaches to solve this problem:
  1. Approach #1 (Combining structs and enums) - Not so good
    ```rust
    enum IpAddrKind {
      V4,
      V6,
    }

    struct IpAddr {
      kind: IpAddrKind,
      address: String,
    }

    let home = IpAddr {
      kind: IpAddrKind::V4,
      address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
      kind: IpAddrKind::V6,
      address: String::from("::1"),
    };
    ```
    * __We’ve used a ```struct``` to bundle the ```kind``` and ```address``` values together, so now the variant is associated with the value.__
  2. Approach #2 (Using only enums) - Better
    ```rust
    enum IpAddr {
      V4(String),
      V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
    ```
    * __However, representing the same concept using just an ```enum``` is way more concise: rather than an ```enum``` inside a ```struct```, we can put data directly into each ```enum``` variant.__
    * __We attach data to each variant of the ```enum``` directly, so there is no need for an extra struct.__
    * __Here, it’s also easier to see another detail of how ```enums``` work: the name of each ```enum``` variant that we define also becomes a function that constructs an instance of the ```enum```.__
    * That is, ```IpAddr::V4()``` is a function call that takes a ```String``` argument and returns an instance of the ```IpAddr``` type. We automatically get this constructor function defined as a result of defining the ```enum```.
    * __There’s another important advantage to using an ```enum``` rather than a ```struct```: each variant can have different types and amounts of associated data.__
      * IP addresses (V4) will always have four numeric components that will have values between 0 and 255.
      * IP addresses (V6) will always have an alphanumeric value.
    * __If we wanted to store V4 addresses as four ```u8``` values but still express V6 addresses as one ```String``` value, we wouldn’t be able to with a ```struct```, since it does not provide such flexibility.__
    * However, we can do this with ease by using enums:
    ```rust
    enum IpAddr {
      V4(u8, u8, u8, u8),
      V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
    ```
* __IMPORTANT: You can put any kind of data inside an ```enum``` variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.__

## Taking a deeper dive into the use of ```enum```
* Let’s look at another example of an ```enum```. This one has a wide variety of types embedded in its variants:
```rust
enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(i32, i32, i32),
}
```
* As you can see, this newly created ```enum``` has 4 possible variants. Namely:
  * ```Quit```: Which has no data associated with it at all.
  * ```Move```: Which has named fields, like a ```struct``` does.
  * ```Write```: Which includes a single ```String``` value.
  * ```ChangeColor```: Which includes 3 ```i32``` values.
* __Pay atention to the following: Defining an ```enum``` with variants such as the ones above is similar to defining different kinds of ```struct``` definitions, except the ```enum``` doesn’t use the ```struct``` keyword and all the variants are grouped together under the ```Message```. However, if we used the different structs, each of which has its own type, we couldn’t as easily define a function to take any of these kinds of messages as we could with the ```Message``` enum.__
* __There is one more similarity between enums and structs: just as we’re able to define methods on structs using ```impl```, we’re also able to define methods on enums, as the example of code snippet below shows:__
```rust
impl Message {
  fn call(&self) {
    // method body would be defined here
  }
}

let m = Message::Write(String::from("hello"));
m.call();
```
* The body of the method would use ```self``` to get the value that we called the method on. In this example, we’ve created a variable ```m``` that has the value ```Message::Write(String::from("hello"))```, and that is what ```self``` will be in the body of the ```call``` method when ```m.call()``` runs.

## The ```Option``` Enum and Its Advantages Over Null Values
* This section explores a case study of ```Option```, which is another enum defined by the standard library.
* __The ```Option``` type encodes the very common scenario in which a value could be something or it could be nothing.__
* For example, if you request the first item in a non-empty list, you would get a value. If you request the first item in an empty list, you would get nothing.
* __Expressing this concept in terms of the type system means the compiler can check whether you’ve handled all the cases you should be handling. This functionality can prevent bugs that are extremely common in other programming languages.__
* __IMPORTANT: Rust doesn’t have the null feature that many other languages have. Null is a value that means there is no value there. In languages with null, variables can always be in one of two states: null or not-null.__
* __Quote from Tony Hoare, the invetor of ```Null```: "At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.".__
* The problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.
* __However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.__
* __IMPORTANT: The problem isn’t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent.__
* Such enum is called ```Option<T>```.
```rust
enum Option<T> {
  None,
  Some(T),
}
```
* The ```Option<T>``` enum is so useful that it’s even included in the prelude. This means that you don’t need to bring it into scope explicitly.
* The variants (possible values) of the ```Option<T>``` enum are also included in the prelude. Thus, you can use ```Some``` and ```None``` directly without the ```Option::``` prefix.
* __The ```<T>``` syntax is a feature of Rust we haven’t talked about yet. It’s a generic type parameter. For now, all you need to know is that ```<T>``` means that the ```Some``` variant of the ```Option``` enum can hold one piece of data of any type, and that each concrete type that gets used in place of ```T``` makes the overall ```Option<T>``` type a different type (which means that ```Option<i32>``` and ```Option<u32>``` are different types, for example).__
* Example of Rust code snippet that show this idea:
```rust
let some_number = Some(5); // Is of type Option<i32>.
let some_char = Some('e'); // Is of type Option<char>. 

let absent_number: Option<i32> = None; // Is of type Option<i32>.
```
* __For the first two variables (```some_number``` and ```some_char```) Rust can infer these types (we don't need to write type annotations) because we’ve specified a value inside the ```Some``` variant.__
* __For the last variable (```absent_number```) we need to annotate the overall ```Option``` type: the compiler can’t infer the type that the corresponding ```Some``` variant will hold by looking only at a ```None``` value. Here, we tell Rust that we mean for ```absent_number``` to be of type ```Option<i32>```.__
* Therefore, we have the following:
  * When we have a ```Some``` value, we know that a value is present and the value is held within the ```Some```. 
  * When we have a ```None``` value, in some sense it means the same thing as null. In other words, we don’t have a valid value.
* __IMPORTANT: So why is having ```Option<T>``` any better than having null?__
  * __In short, because ```Option<T>``` and ```T``` (where ```T``` can be any type) are different types, the compiler won’t let us use an ```Option<T>``` value as if it were definitely a valid value.__
  * __We can see this in the following code snippet that the Rust compiler won't compile:__
  ```rust
  let x: i8 = 5;
  let y: Option<i8> = Some(5);

  let sum = x + y; // This line will throw a compiler error.
  ```
  * __In effect, the error message means that Rust doesn’t understand how to add an ```i8``` and an ```Option<i8>```, because they’re different types:__
    * __When we have a value of a type like ```i8``` in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value.__
    * __However, when we have an ```Option<i8>``` (or whatever type of value we’re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.__
    * __In other words, you have to convert an ```Option<T>``` to a ```T``` before you can perform ```T``` operations with it.__
    * __Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.__

## Dealing with ```Option<T>```
* In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value ```Option<T>```.
* Then, when you use that value, you are required to explicitly handle the case when the value is null.
* Everywhere that a value has a type that isn’t an ```Option<T>```, you can safely assume that the value isn’t null (this was a deliberate design decision for Rust to limit null’s pervasiveness and increase the safety of Rust code).
* So how do you get the ```T``` value out of a ```Some``` variant when you have a value of type ```Option<T>``` so that you can use that value? The ```Option<T>``` enum has a large number of methods that are useful in a variety of situations. Check the official docs to know what methods are available and how you can use them.
* __In general, in order to use an ```Option<T>``` value, you want to have code that will handle each variant:__ 
  * You want some code that will run only when you have a ```Some(T)``` value, and this code is allowed to use the inner ```T``` value.
  * You want some other code to run only if you have a ```None``` value, and that code doesn’t have a ```T``` value available.
  * The ```match``` expression is a control flow construct that does just this when used with enums. It will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.
