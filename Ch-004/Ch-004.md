# Chapter 004 - Understanding Ownership

## Intro
* Ownership is the most important feature of the Rust language. Moreover, it's this feature that distincts it from other programming languages.
* It's also safe to say that such feature has deep implications for the rest of the language.
* __It's ownership that allows Rust to make its famous safety guarantees without the need of a Garbage Collector (GC).__
* __The concept of Ownership is tied to other important concepts:__
    * Borrowing
    * Slices
    * Data layout in Memory

## What is Ownership?
* __A set of rules that govern how a Rust program manages memory.__
* Common approaches used by popular programming languages:
    * Garbage collection keep looking for unused variables in the memory while the programming is running (Java, Python, JavaScript).
    * Us, the programmers, must explicitly allocate and deallocate (free) the memory (C, C++).
* __Ok... But how does Ownership manages the memory? Such set of rules is checked by the compiler at compile time. If at least one of such rules is not followed, then the program won't compile and, thus, won't run.__
* Pay attention to the fact that the Ownership system does not slow down the execution of Rust programs.
* __It does take some time to get used to it, since it's a new way of programming. But as you get used to it, you will be able to write code that is more safe and performant.__

## The Stack and The Heap
* Both are region of the memory available for your program to use at runtime.
* However, there are a couple differences when it comes to how these regions of memory work and are structured.
* __Stack__
    * __Stores values inside itself following a LIFO (Last-In First-Out) policy.__
    * __All data stored inside the stack must have known and fixed size at compile time.__
    * __Have a well-defined structure due to its policy regarding insertion and deletion of elements.__
* __Heap__
    * __Stores values in a less-organized way.__
    * __The process goes as follows: The memory allocator finds an empty spot inside the heap that is big enough for the data that you want to store, marks it as 'being used' and returns the address of such location in memory (pointer).__
    * __Because the pointer to the heap is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.__
        * How can I know the size of a pointer? Does the size change if it points to different types of data in the heap?
* Pushing to the stack is faster than allocating on the heap because the allocator never has to search for a place to store new data; that location is always at the top of the stack.
* Comparatively, allocating space on the heap requires more work because the allocator must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation.
* Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there.
* __A processor can do its job better if it works on data that’s close to other data (as it is on the stack) rather than farther away (as it can be on the heap).__
* __When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.__
* __The main purpose of Ownership is to manage Heap data:__
    * __Keeping track of what parts of code are using what data on the Heap.__
    * __Minimizing the amount of duplicate data on the Heap.__
    * __Cleaning up unused data on the Heap so you don’t run out of space.__


